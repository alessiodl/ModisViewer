{"dependencies":[{"name":"./TileState.js","loc":{"line":17,"column":22}},{"name":"./events/EventType.js","loc":{"line":18,"column":22}},{"name":"./structs/PriorityQueue.js","loc":{"line":19,"column":26}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _TileState = require(\"./TileState.js\");\n\nvar _TileState2 = _interopRequireDefault(_TileState);\n\nvar _EventType = require(\"./events/EventType.js\");\n\nvar _EventType2 = _interopRequireDefault(_EventType);\n\nvar _PriorityQueue = require(\"./structs/PriorityQueue.js\");\n\nvar _PriorityQueue2 = _interopRequireDefault(_PriorityQueue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/TileQueue\n */\n\n/**\n * @typedef {function(import(\"./Tile.js\").default, string, import(\"./coordinate.js\").Coordinate, number): number} PriorityFunction\n */\nvar TileQueue = /** @class */function (_super) {\n  __extends(TileQueue, _super);\n  /**\n   * @param {PriorityFunction} tilePriorityFunction Tile priority function.\n   * @param {function(): ?} tileChangeCallback Function called on each tile change event.\n   */\n  function TileQueue(tilePriorityFunction, tileChangeCallback) {\n    var _this = _super.call(this,\n    /**\n     * @param {Array} element Element.\n     * @return {number} Priority.\n     */\n    function (element) {\n      return tilePriorityFunction.apply(null, element);\n    },\n    /**\n     * @param {Array} element Element.\n     * @return {string} Key.\n     */\n    function (element) {\n      return (/** @type {import(\"./Tile.js\").default} */element[0].getKey()\n      );\n    }) || this;\n    /** @private */\n    _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);\n    /**\n     * @private\n     * @type {function(): ?}\n     */\n    _this.tileChangeCallback_ = tileChangeCallback;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.tilesLoading_ = 0;\n    /**\n     * @private\n     * @type {!Object<string,boolean>}\n     */\n    _this.tilesLoadingKeys_ = {};\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n  TileQueue.prototype.enqueue = function (element) {\n    var added = _super.prototype.enqueue.call(this, element);\n    if (added) {\n      var tile = element[0];\n      tile.addEventListener(_EventType2.default.CHANGE, this.boundHandleTileChange_);\n    }\n    return added;\n  };\n  /**\n   * @return {number} Number of tiles loading.\n   */\n  TileQueue.prototype.getTilesLoading = function () {\n    return this.tilesLoading_;\n  };\n  /**\n   * @param {import(\"./events/Event.js\").default} event Event.\n   * @protected\n   */\n  TileQueue.prototype.handleTileChange = function (event) {\n    var tile = /** @type {import(\"./Tile.js\").default} */event.target;\n    var state = tile.getState();\n    if (tile.hifi && state === _TileState2.default.LOADED || state === _TileState2.default.ERROR || state === _TileState2.default.EMPTY || state === _TileState2.default.ABORT) {\n      tile.removeEventListener(_EventType2.default.CHANGE, this.boundHandleTileChange_);\n      var tileKey = tile.getKey();\n      if (tileKey in this.tilesLoadingKeys_) {\n        delete this.tilesLoadingKeys_[tileKey];\n        --this.tilesLoading_;\n      }\n      this.tileChangeCallback_();\n    }\n  };\n  /**\n   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n   * @param {number} maxNewLoads Maximum number of new tiles to load.\n   */\n  TileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {\n    var newLoads = 0;\n    var abortedTiles = false;\n    var state, tile, tileKey;\n    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {\n      tile = /** @type {import(\"./Tile.js\").default} */this.dequeue()[0];\n      tileKey = tile.getKey();\n      state = tile.getState();\n      if (state === _TileState2.default.ABORT) {\n        abortedTiles = true;\n      } else if (state === _TileState2.default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n        this.tilesLoadingKeys_[tileKey] = true;\n        ++this.tilesLoading_;\n        ++newLoads;\n        tile.load();\n      }\n    }\n    if (newLoads === 0 && abortedTiles) {\n      // Do not stop the render loop when all wanted tiles were aborted due to\n      // a small, saturated tile cache.\n      this.tileChangeCallback_();\n    }\n  };\n  return TileQueue;\n}(_PriorityQueue2.default);\nexports.default = TileQueue;\n//# sourceMappingURL=TileQueue.js.map"},"hash":"a789085040a43bac35efdb4b4bb54463"}