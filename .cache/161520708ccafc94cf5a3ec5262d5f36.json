{"dependencies":[{"name":"../util.js","loc":{"line":17,"column":23}},{"name":"../asserts.js","loc":{"line":18,"column":23}},{"name":"../Feature.js","loc":{"line":19,"column":20}},{"name":"../geom/GeometryType.js","loc":{"line":20,"column":25}},{"name":"../coordinate.js","loc":{"line":21,"column":63}},{"name":"../events/EventType.js","loc":{"line":22,"column":22}},{"name":"../extent.js","loc":{"line":23,"column":66}},{"name":"../geom/Point.js","loc":{"line":24,"column":18}},{"name":"./Vector.js","loc":{"line":25,"column":25}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _util = require(\"../util.js\");\n\nvar _asserts = require(\"../asserts.js\");\n\nvar _Feature = require(\"../Feature.js\");\n\nvar _Feature2 = _interopRequireDefault(_Feature);\n\nvar _GeometryType = require(\"../geom/GeometryType.js\");\n\nvar _GeometryType2 = _interopRequireDefault(_GeometryType);\n\nvar _coordinate = require(\"../coordinate.js\");\n\nvar _EventType = require(\"../events/EventType.js\");\n\nvar _EventType2 = _interopRequireDefault(_EventType);\n\nvar _extent = require(\"../extent.js\");\n\nvar _Point = require(\"../geom/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Vector = require(\"./Vector.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @module ol/source/Cluster\n */\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Minimum distance in pixels between clusters.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underyling source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {VectorSource} source Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n * @api\n */\nvar Cluster = /** @class */function (_super) {\n  __extends(Cluster, _super);\n  /**\n   * @param {Options} options Cluster options.\n   */\n  function Cluster(options) {\n    var _this = _super.call(this, {\n      attributions: options.attributions,\n      wrapX: options.wrapX\n    }) || this;\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    _this.resolution = undefined;\n    /**\n     * @type {number}\n     * @protected\n     */\n    _this.distance = options.distance !== undefined ? options.distance : 20;\n    /**\n     * @type {Array<Feature>}\n     * @protected\n     */\n    _this.features = [];\n    /**\n     * @param {Feature} feature Feature.\n     * @return {Point} Cluster calculation point.\n     * @protected\n     */\n    _this.geometryFunction = options.geometryFunction || function (feature) {\n      var geometry = feature.getGeometry();\n      (0, _asserts.assert)(geometry.getType() == _GeometryType2.default.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries\n      return geometry;\n    };\n    /**\n     * @type {VectorSource}\n     * @protected\n     */\n    _this.source = options.source;\n    _this.source.addEventListener(_EventType2.default.CHANGE, _this.refresh.bind(_this));\n    return _this;\n  }\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n  Cluster.prototype.getDistance = function () {\n    return this.distance;\n  };\n  /**\n   * Get a reference to the wrapped source.\n   * @return {VectorSource} Source.\n   * @api\n   */\n  Cluster.prototype.getSource = function () {\n    return this.source;\n  };\n  /**\n   * @inheritDoc\n   */\n  Cluster.prototype.loadFeatures = function (extent, resolution, projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n    if (resolution !== this.resolution) {\n      this.clear();\n      this.resolution = resolution;\n      this.cluster();\n      this.addFeatures(this.features);\n    }\n  };\n  /**\n   * Set the distance in pixels between clusters.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n  Cluster.prototype.setDistance = function (distance) {\n    this.distance = distance;\n    this.refresh();\n  };\n  /**\n   * handle the source changing\n   * @override\n   */\n  Cluster.prototype.refresh = function () {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  };\n  /**\n   * @protected\n   */\n  Cluster.prototype.cluster = function () {\n    if (this.resolution === undefined) {\n      return;\n    }\n    this.features.length = 0;\n    var extent = (0, _extent.createEmpty)();\n    var mapDistance = this.distance * this.resolution;\n    var features = this.source.getFeatures();\n    /**\n     * @type {!Object<string, boolean>}\n     */\n    var clustered = {};\n    for (var i = 0, ii = features.length; i < ii; i++) {\n      var feature = features[i];\n      if (!((0, _util.getUid)(feature) in clustered)) {\n        var geometry = this.geometryFunction(feature);\n        if (geometry) {\n          var coordinates = geometry.getCoordinates();\n          (0, _extent.createOrUpdateFromCoordinate)(coordinates, extent);\n          (0, _extent.buffer)(extent, mapDistance, extent);\n          var neighbors = this.source.getFeaturesInExtent(extent);\n          neighbors = neighbors.filter(function (neighbor) {\n            var uid = (0, _util.getUid)(neighbor);\n            if (!(uid in clustered)) {\n              clustered[uid] = true;\n              return true;\n            } else {\n              return false;\n            }\n          });\n          this.features.push(this.createCluster(neighbors));\n        }\n      }\n    }\n  };\n  /**\n   * @param {Array<Feature>} features Features\n   * @return {Feature} The cluster feature.\n   * @protected\n   */\n  Cluster.prototype.createCluster = function (features) {\n    var centroid = [0, 0];\n    for (var i = features.length - 1; i >= 0; --i) {\n      var geometry = this.geometryFunction(features[i]);\n      if (geometry) {\n        (0, _coordinate.add)(centroid, geometry.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n    (0, _coordinate.scale)(centroid, 1 / features.length);\n    var cluster = new _Feature2.default(new _Point2.default(centroid));\n    cluster.set('features', features);\n    return cluster;\n  };\n  return Cluster;\n}(_Vector2.default);\nexports.default = Cluster;\n//# sourceMappingURL=Cluster.js.map"},"hash":"c2ccb923e6d8d820b98892df7bd4ef64"}