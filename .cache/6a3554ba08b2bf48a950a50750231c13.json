{"dependencies":[{"name":"../../util.js","loc":{"line":17,"column":23}},{"name":"../../TileState.js","loc":{"line":18,"column":22}},{"name":"../../ViewHint.js","loc":{"line":19,"column":21}},{"name":"../../events.js","loc":{"line":20,"column":38}},{"name":"../../events/EventType.js","loc":{"line":21,"column":22}},{"name":"../../extent.js","loc":{"line":22,"column":118}},{"name":"../../layer/VectorTileRenderType.js","loc":{"line":23,"column":33}},{"name":"../../render/canvas/BuilderType.js","loc":{"line":24,"column":23}},{"name":"../../render/canvas/BuilderGroup.js","loc":{"line":25,"column":31}},{"name":"./TileLayer.js","loc":{"line":26,"column":36}},{"name":"../../size.js","loc":{"line":27,"column":23}},{"name":"../vector.js","loc":{"line":28,"column":80}},{"name":"../../transform.js","loc":{"line":29,"column":167}},{"name":"../../render/canvas/ExecutorGroup.js","loc":{"line":30,"column":53}},{"name":"../../obj.js","loc":{"line":31,"column":22}},{"name":"../../render/canvas/hitdetect.js","loc":{"line":32,"column":55}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _util = require(\"../../util.js\");\n\nvar _TileState = require(\"../../TileState.js\");\n\nvar _TileState2 = _interopRequireDefault(_TileState);\n\nvar _ViewHint = require(\"../../ViewHint.js\");\n\nvar _ViewHint2 = _interopRequireDefault(_ViewHint);\n\nvar _events = require(\"../../events.js\");\n\nvar _EventType = require(\"../../events/EventType.js\");\n\nvar _EventType2 = _interopRequireDefault(_EventType);\n\nvar _extent = require(\"../../extent.js\");\n\nvar _VectorTileRenderType = require(\"../../layer/VectorTileRenderType.js\");\n\nvar _VectorTileRenderType2 = _interopRequireDefault(_VectorTileRenderType);\n\nvar _BuilderType = require(\"../../render/canvas/BuilderType.js\");\n\nvar _BuilderType2 = _interopRequireDefault(_BuilderType);\n\nvar _BuilderGroup = require(\"../../render/canvas/BuilderGroup.js\");\n\nvar _BuilderGroup2 = _interopRequireDefault(_BuilderGroup);\n\nvar _TileLayer = require(\"./TileLayer.js\");\n\nvar _TileLayer2 = _interopRequireDefault(_TileLayer);\n\nvar _size = require(\"../../size.js\");\n\nvar _vector = require(\"../vector.js\");\n\nvar _transform = require(\"../../transform.js\");\n\nvar _ExecutorGroup = require(\"../../render/canvas/ExecutorGroup.js\");\n\nvar _ExecutorGroup2 = _interopRequireDefault(_ExecutorGroup);\n\nvar _obj = require(\"../../obj.js\");\n\nvar _hitdetect = require(\"../../render/canvas/hitdetect.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nvar IMAGE_REPLAYS = {\n  'image': [_BuilderType2.default.POLYGON, _BuilderType2.default.CIRCLE, _BuilderType2.default.LINE_STRING, _BuilderType2.default.IMAGE, _BuilderType2.default.TEXT],\n  'hybrid': [_BuilderType2.default.POLYGON, _BuilderType2.default.LINE_STRING]\n};\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas/BuilderType.js\").default>>}\n */\nvar VECTOR_REPLAYS = {\n  'image': [_BuilderType2.default.DEFAULT],\n  'hybrid': [_BuilderType2.default.IMAGE, _BuilderType2.default.TEXT, _BuilderType2.default.DEFAULT]\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nvar CanvasVectorTileLayerRenderer = /** @class */function (_super) {\n  __extends(CanvasVectorTileLayerRenderer, _super);\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  function CanvasVectorTileLayerRenderer(layer) {\n    var _this = _super.call(this, layer) || this;\n    /** @private */\n    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.renderedLayerRevision_;\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    _this.renderedPixelToCoordinateTransform_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.renderedRotation_;\n    /**\n     * @private\n     * @type {!Object<string, import(\"../../VectorRenderTile.js\").default>}\n     */\n    _this.renderTileImageQueue_ = {};\n    /**\n     * @type {Object<string, import(\"../../events.js\").EventsKey>}\n     */\n    _this.tileListenerKeys_ = {};\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    _this.tmpTransform_ = (0, _transform.create)();\n    return _this;\n  }\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection\").default} projection Projection.\n   * @param {boolean} queue Queue tile for rendering.\n   * @return {boolean|undefined} Tile needs to be rendered.\n   */\n  CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection, queue) {\n    var render;\n    var tileUid = (0, _util.getUid)(tile);\n    var state = tile.getState();\n    if ((state === _TileState2.default.LOADED && tile.hifi || state === _TileState2.default.ERROR || state === _TileState2.default.ABORT) && tileUid in this.tileListenerKeys_) {\n      (0, _events.unlistenByKey)(this.tileListenerKeys_[tileUid]);\n      delete this.tileListenerKeys_[tileUid];\n    }\n    if (state === _TileState2.default.LOADED || state === _TileState2.default.ERROR) {\n      this.updateExecutorGroup_(tile, pixelRatio, projection);\n      if (this.tileImageNeedsRender_(tile, pixelRatio, projection)) {\n        render = true;\n        if (queue) {\n          this.renderTileImageQueue_[tileUid] = tile;\n        }\n      }\n    }\n    return render;\n  };\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {\n    var tile = /** @type {import(\"../../VectorRenderTile.js\").default} */_super.prototype.getTile.call(this, z, x, y, frameState);\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var resolution = viewState.resolution;\n    var projection = viewState.projection;\n    if (tile.getState() < _TileState2.default.LOADED) {\n      tile.wantedResolution = resolution;\n      var tileUid = (0, _util.getUid)(tile);\n      if (!(tileUid in this.tileListenerKeys_)) {\n        var listenerKey = (0, _events.listen)(tile, _EventType2.default.CHANGE, this.prepareTile.bind(this, tile, pixelRatio, projection, true));\n        this.tileListenerKeys_[tileUid] = listenerKey;\n      }\n    } else {\n      var viewHints = frameState.viewHints;\n      var hifi = !(viewHints[_ViewHint2.default.ANIMATING] || viewHints[_ViewHint2.default.INTERACTING]);\n      if (hifi || !tile.wantedResolution) {\n        tile.wantedResolution = resolution;\n      }\n      var render = this.prepareTile(tile, pixelRatio, projection, false);\n      if (render) {\n        this.renderTileImage_(tile, frameState);\n      }\n    }\n    return tile;\n  };\n  /**\n   * @inheritdoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {\n    return _super.prototype.isDrawableTile.call(this, tile) && tile.hasContext(this.getLayer());\n  };\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {\n    return tile.getImage(this.getLayer());\n  };\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {\n    var layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return _super.prototype.prepareFrame.call(this, frameState);\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder = layer.getRenderOrder() || null;\n    var resolution = tile.wantedResolution;\n    var builderState = tile.getReplayState(layer);\n    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder && builderState.renderedZ === tile.sourceZ) {\n      return;\n    }\n    var source = layer.getSource();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    var layerUid = (0, _util.getUid)(layer);\n    var executorGroups = tile.executorGroups[layerUid];\n    if (executorGroups) {\n      for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n        executorGroups[i].dispose();\n      }\n    }\n    tile.hitDetectionImageData = null;\n    tile.executorGroups[layerUid] = [];\n    var _loop_1 = function (t, tt) {\n      var sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != _TileState2.default.LOADED) {\n        return \"continue\";\n      }\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = (0, _extent.getIntersection)(tileExtent, sourceTileExtent);\n      var bufferedExtent = (0, _extent.equals)(sourceTileExtent, sharedExtent) ? null : (0, _extent.buffer)(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);\n      builderState.dirty = false;\n      var builderGroup = new _BuilderGroup2.default(0, sharedExtent, resolution, pixelRatio, layer.getDeclutter());\n      var squaredTolerance = (0, _vector.getSquaredTolerance)(resolution, pixelRatio);\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      var render = function (feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n      var features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        var feature = features[i];\n        if (!bufferedExtent || (0, _extent.intersects)(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this_1, feature);\n        }\n      }\n      var executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      var replayExtent = layer.getDeclutter() && sourceTiles.length === 1 ? null : sharedExtent;\n      var renderingReplayGroup = new _ExecutorGroup2.default(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    };\n    var this_1 = this;\n    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      _loop_1(t, tt);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedZ = tile.sourceZ;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  };\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var declutter = layer.getDeclutter();\n    var source = layer.getSource();\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    /** @type {!Object<string, boolean>} */\n    var features = {};\n    var renderedTiles = /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */this.renderedTiles;\n    var found;\n    var i, ii;\n    var _loop_2 = function () {\n      var tile = renderedTiles[i];\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var tileContainsCoordinate = (0, _extent.containsCoordinate)(tileExtent, coordinate);\n      if (!declutter) {\n        // When not decluttering, we only need to consider the tile that contains the given\n        // coordinate, because each feature will be rendered for each tile that contains it.\n        if (!tileContainsCoordinate) {\n          return \"continue\";\n        }\n      }\n      var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];\n      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n        var executorGroup = executorGroups[t];\n        found = found || executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance,\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @return {?} Callback result.\n         */\n        function (feature) {\n          if (tileContainsCoordinate || declutteredFeatures && declutteredFeatures.indexOf(feature) !== -1) {\n            var key = feature.getId();\n            if (key === undefined) {\n              key = (0, _util.getUid)(feature);\n            }\n            if (!(key in features)) {\n              features[key] = true;\n              return callback(feature, layer);\n            }\n          }\n        }, layer.getDeclutter() ? declutteredFeatures : null);\n      }\n    };\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      _loop_2();\n    }\n    return found;\n  };\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.getFeatures = function (pixel) {\n    return new Promise(function (resolve, reject) {\n      var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n      var source = layer.getSource();\n      var projection = this.renderedProjection;\n      var projectionExtent = projection.getExtent();\n      var resolution = this.renderedResolution;\n      var tileGrid = source.getTileGridForProjection(projection);\n      var coordinate = (0, _transform.apply)(this.renderedPixelToCoordinateTransform_, pixel.slice());\n      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n      var tile;\n      for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {\n          tile = this.renderedTiles[i];\n          if (tile.getState() === _TileState2.default.LOADED && tile.hifi) {\n            var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (source.getWrapX() && projection.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent_1)) {\n              var worldWidth = (0, _extent.getWidth)(projectionExtent);\n              var worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / worldWidth);\n              coordinate[0] -= worldsAway * worldWidth;\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile) {\n        resolve([]);\n        return;\n      }\n      var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var corner = (0, _extent.getTopLeft)(extent);\n      var tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];\n      var features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      if (!tile.hitDetectionImageData) {\n        var tileSize_1 = (0, _size.toSize)(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));\n        var size = [tileSize_1[0] / 2, tileSize_1[1] / 2];\n        var rotation_1 = this.renderedRotation_;\n        var transforms_1 = [this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, 0.5, size[0], size[1], 0)];\n        requestAnimationFrame(function () {\n          tile.hitDetectionImageData = (0, _hitdetect.createHitDetectionImageData)(tileSize_1, transforms_1, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation_1);\n          resolve((0, _hitdetect.hitDetect)(tilePixel, features, tile.hitDetectionImageData));\n        });\n      } else {\n        resolve((0, _hitdetect.hitDetect)(tilePixel, features, tile.hitDetectionImageData));\n      }\n    }.bind(this));\n  };\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {\n    (0, _obj.clear)(this.renderTileImageQueue_);\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {\n    var viewHints = frameState.viewHints;\n    var hifi = !(viewHints[_ViewHint2.default.ANIMATING] || viewHints[_ViewHint2.default.INTERACTING]);\n    this.renderQueuedTileImages_(hifi, frameState);\n    _super.prototype.renderFrame.call(this, frameState, target);\n    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var renderMode = layer.getRenderMode();\n    if (renderMode === _VectorTileRenderType2.default.IMAGE) {\n      return this.container;\n    }\n    var source = layer.getSource();\n    // Unqueue tiles from the image queue when we don't need any more\n    var usedTiles = frameState.usedTiles[(0, _util.getUid)(source)];\n    for (var tileUid in this.renderTileImageQueue_) {\n      if (!usedTiles || !(tileUid in usedTiles)) {\n        delete this.renderTileImageQueue_[tileUid];\n      }\n    }\n    var context = this.context;\n    var declutterReplays = layer.getDeclutter() ? {} : null;\n    var replayTypes = VECTOR_REPLAYS[renderMode];\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var center = viewState.center;\n    var resolution = viewState.resolution;\n    var rotation = viewState.rotation;\n    var size = frameState.size;\n    var width = Math.round(size[0] * pixelRatio);\n    var height = Math.round(size[1] * pixelRatio);\n    var tiles = this.renderedTiles;\n    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    var clips = [];\n    var clipZs = [];\n    for (var i = tiles.length - 1; i >= 0; --i) {\n      var tile = /** @type {import(\"../../VectorRenderTile.js\").default} */tiles[i];\n      if (tile.getState() == _TileState2.default.ABORT) {\n        continue;\n      }\n      var tileCoord = tile.tileCoord;\n      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];\n      var transform = (0, _transform.multiply)((0, _transform.scale)(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n      var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];\n      var clipped = false;\n      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {\n        var executorGroup = executorGroups[t];\n        if (!executorGroup.hasExecutors(replayTypes)) {\n          // sourceTile has no instructions of the types we want to render\n          continue;\n        }\n        var currentZ = tile.tileCoord[0];\n        var currentClip = void 0;\n        if (!declutterReplays && !clipped) {\n          currentClip = executorGroup.getClipCoords(transform);\n          context.save();\n          // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n          for (var j = 0, jj = clips.length; j < jj; ++j) {\n            var clip = clips[j];\n            if (currentZ < clipZs[j]) {\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher resolution tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        executorGroup.execute(context, transform, rotation, hifi, replayTypes, declutterReplays);\n        if (!declutterReplays && !clipped) {\n          context.restore();\n          clips.push(currentClip);\n          clipZs.push(currentZ);\n          clipped = true;\n        }\n      }\n    }\n    if (declutterReplays) {\n      var layerState = frameState.layerStatesArray[frameState.layerIndex];\n      (0, _ExecutorGroup.replayDeclutter)(declutterReplays, context, rotation, layerState.opacity, hifi, frameState.declutterItems);\n    }\n    return this.container;\n  };\n  /**\n   * @param {boolean} hifi We have time to render a high fidelity map image.\n   * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderQueuedTileImages_ = function (hifi, frameState) {\n    // When we don't have time to render hifi, only render tiles until we have used up\n    // half of the frame budget of 16 ms\n    for (var uid in this.renderTileImageQueue_) {\n      if (!hifi && Date.now() - frameState.time > 8) {\n        frameState.animate = true;\n        break;\n      }\n      var tile = this.renderTileImageQueue_[uid];\n      delete this.renderTileImageQueue_[uid];\n      this.renderTileImage_(tile, frameState);\n    }\n  };\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} executorGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, executorGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = (0, _vector.renderFeature)(executorGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_) || loading;\n      }\n    } else {\n      loading = (0, _vector.renderFeature)(executorGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_);\n    }\n    return loading;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile, pixelRatio, projection) {\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var sourceZ = tile.sourceZ;\n    var resolution = tile.wantedResolution;\n    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision || replayState.renderedTileZ !== sourceZ;\n  };\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {\n    var layer = /** @type {import(\"../../layer/VectorTile.js\").default} */this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];\n    replayState.renderedTileRevision = revision;\n    replayState.renderedTileZ = tile.sourceZ;\n    var tileCoord = tile.wrappedTileCoord;\n    var z = tileCoord[0];\n    var source = layer.getSource();\n    var pixelRatio = frameState.pixelRatio;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var tileGrid = source.getTileGridForProjection(projection);\n    var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;\n    var resolution = tileGrid.getResolution(z);\n    var context = tile.getContext(layer);\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.max(pixelRatio, renderPixelRatio / pixelRatio);\n    var size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    var renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      var canvasTransform = (0, _transform.reset)(this.tmpTransform_);\n      (0, _transform.scale)(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var pixelScale = renderPixelRatio / resolution;\n    var transform = (0, _transform.reset)(this.tmpTransform_);\n    (0, _transform.scale)(transform, pixelScale, -pixelScale);\n    (0, _transform.translate)(transform, -tileExtent[0], -tileExtent[3]);\n    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {\n      var executorGroup = executorGroups[i];\n      executorGroup.execute(context, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  };\n  return CanvasVectorTileLayerRenderer;\n}(_TileLayer2.default);\nexports.default = CanvasVectorTileLayerRenderer;\n//# sourceMappingURL=VectorTileLayer.js.map"},"hash":"896f95a3895e46270c34a4d16dd87620"}