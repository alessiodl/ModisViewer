{"dependencies":[{"name":"../TileState.js","loc":{"line":17,"column":22}},{"name":"../VectorRenderTile.js","loc":{"line":18,"column":29}},{"name":"../VectorTile.js","loc":{"line":19,"column":17}},{"name":"../size.js","loc":{"line":20,"column":23}},{"name":"./UrlTile.js","loc":{"line":21,"column":20}},{"name":"../tilecoord.js","loc":{"line":22,"column":34}},{"name":"../tilegrid.js","loc":{"line":23,"column":69}},{"name":"../extent.js","loc":{"line":24,"column":68}},{"name":"../events/EventType.js","loc":{"line":25,"column":22}},{"name":"../featureloader.js","loc":{"line":26,"column":32}},{"name":"../array.js","loc":{"line":27,"column":31}},{"name":"../events.js","loc":{"line":28,"column":38}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultLoadFunction = defaultLoadFunction;\n\nvar _TileState = require(\"../TileState.js\");\n\nvar _TileState2 = _interopRequireDefault(_TileState);\n\nvar _VectorRenderTile = require(\"../VectorRenderTile.js\");\n\nvar _VectorRenderTile2 = _interopRequireDefault(_VectorRenderTile);\n\nvar _VectorTile = require(\"../VectorTile.js\");\n\nvar _VectorTile2 = _interopRequireDefault(_VectorTile);\n\nvar _size = require(\"../size.js\");\n\nvar _UrlTile = require(\"./UrlTile.js\");\n\nvar _UrlTile2 = _interopRequireDefault(_UrlTile);\n\nvar _tilecoord = require(\"../tilecoord.js\");\n\nvar _tilegrid = require(\"../tilegrid.js\");\n\nvar _extent = require(\"../extent.js\");\n\nvar _EventType = require(\"../events/EventType.js\");\n\nvar _EventType2 = _interopRequireDefault(_EventType);\n\nvar _featureloader = require(\"../featureloader.js\");\n\nvar _array = require(\"../array.js\");\n\nvar _events = require(\"../events.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @module ol/source/VectorTile\n */\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize=128] Cache size.\n * @property {import(\"../extent.js\").Extent} [extent]\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level.\n * @property {number} [minZoom] Optional min zoom level.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number} [zDirection=1] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar VectorTile = /** @class */function (_super) {\n  __extends(VectorTile, _super);\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n  function VectorTile(options) {\n    var _this = this;\n    var projection = options.projection || 'EPSG:3857';\n    var extent = options.extent || (0, _tilegrid.extentFromProjection)(projection);\n    var tileGrid = options.tileGrid || (0, _tilegrid.createXYZ)({\n      extent: extent,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection\n    }) || this;\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default}\n     */\n    _this.format_ = options.format ? options.format : null;\n    /**\n     * @type {Object<string, import(\"./VectorTile\").default>}\n     */\n    _this.loadingTiles_ = {};\n    /**\n     * @private\n     * @type {Object<string, import(\"../VectorTile.js\").default>}\n     */\n    _this.sourceTileByCoordKey_ = {};\n    /**\n     * @private\n     * @type {Object<string, Array<import(\"../VectorTile.js\").default>>}\n     */\n    _this.sourceTilesByTileKey_ = {};\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n    _this.tileClass = options.tileClass ? options.tileClass : _VectorTile2.default;\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    _this.tileGrids_ = {};\n    return _this;\n  }\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n  VectorTile.prototype.getOverlaps = function () {\n    return this.overlaps_;\n  };\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n  VectorTile.prototype.clear = function () {\n    this.tileCache.clear();\n    this.sourceTileByCoordKey_ = {};\n    this.sourceTilesByTileKey_ = {};\n  };\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n  VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n    var urlTileCoord = tile.wrappedTileCoord;\n    var tileGrid = this.getTileGridForProjection(projection);\n    var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n    var z = urlTileCoord[0];\n    var resolution = tileGrid.getResolution(z);\n    // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n    (0, _extent.buffer)(extent, -resolution, extent);\n    var sourceTileGrid = this.tileGrid;\n    var sourceExtent = sourceTileGrid.getExtent();\n    if (sourceExtent) {\n      (0, _extent.getIntersection)(extent, sourceExtent, extent);\n    }\n    var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n    var minZoom = sourceTileGrid.getMinZoom();\n    var previousSourceTiles = this.sourceTilesByTileKey_[tile.getKey()];\n    var sourceTiles, covered, loadedZ;\n    if (previousSourceTiles && previousSourceTiles.length > 0 && previousSourceTiles[0].tileCoord[0] === sourceZ) {\n      sourceTiles = previousSourceTiles;\n      covered = true;\n      loadedZ = sourceZ;\n    } else {\n      sourceTiles = [];\n      loadedZ = sourceZ + 1;\n      do {\n        --loadedZ;\n        covered = true;\n        sourceTileGrid.forEachTileCoord(extent, loadedZ, function (sourceTileCoord) {\n          var coordKey = (0, _tilecoord.getKey)(sourceTileCoord);\n          var sourceTile;\n          if (coordKey in this.sourceTileByCoordKey_) {\n            sourceTile = this.sourceTileByCoordKey_[coordKey];\n            var state = sourceTile.getState();\n            if (state === _TileState2.default.LOADED || state === _TileState2.default.ERROR || state === _TileState2.default.EMPTY) {\n              sourceTiles.push(sourceTile);\n              return;\n            }\n          } else if (loadedZ === sourceZ) {\n            var tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n            if (tileUrl !== undefined) {\n              sourceTile = new this.tileClass(sourceTileCoord, _TileState2.default.IDLE, tileUrl, this.format_, this.tileLoadFunction);\n              sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n              sourceTile.projection = projection;\n              sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);\n              this.sourceTileByCoordKey_[coordKey] = sourceTile;\n              sourceTile.addEventListener(_EventType2.default.CHANGE, this.handleTileChange.bind(this));\n              sourceTile.load();\n            }\n          }\n          covered = false;\n          if (!sourceTile) {\n            return;\n          }\n          if (sourceTile.getState() !== _TileState2.default.EMPTY && tile.getState() === _TileState2.default.IDLE) {\n            tile.loadingSourceTiles++;\n            var key_1 = (0, _events.listen)(sourceTile, _EventType2.default.CHANGE, function () {\n              var state = sourceTile.getState();\n              var sourceTileKey = sourceTile.getKey();\n              if (state === _TileState2.default.LOADED || state === _TileState2.default.ERROR) {\n                if (state === _TileState2.default.LOADED) {\n                  (0, _array.remove)(tile.sourceTileListenerKeys, key_1);\n                  (0, _events.unlistenByKey)(key_1);\n                  tile.loadingSourceTiles--;\n                  delete tile.errorSourceTileKeys[sourceTileKey];\n                } else if (state === _TileState2.default.ERROR) {\n                  tile.errorSourceTileKeys[sourceTileKey] = true;\n                }\n                var errorTileCount = Object.keys(tile.errorSourceTileKeys).length;\n                if (tile.loadingSourceTiles - errorTileCount === 0) {\n                  tile.hifi = errorTileCount === 0;\n                  tile.sourceZ = sourceZ;\n                  tile.setState(_TileState2.default.LOADED);\n                }\n              }\n            });\n            tile.sourceTileListenerKeys.push(key_1);\n          }\n        }.bind(this));\n        if (!covered) {\n          sourceTiles.length = 0;\n        }\n      } while (!covered && loadedZ > minZoom);\n    }\n    if (tile.getState() === _TileState2.default.IDLE) {\n      tile.setState(_TileState2.default.LOADING);\n    }\n    if (covered) {\n      tile.hifi = sourceZ === loadedZ;\n      tile.sourceZ = loadedZ;\n      if (tile.getState() < _TileState2.default.LOADED) {\n        tile.setState(_TileState2.default.LOADED);\n      } else if (!previousSourceTiles || !(0, _array.equals)(sourceTiles, previousSourceTiles)) {\n        this.removeSourceTiles(tile);\n        this.addSourceTiles(tile, sourceTiles);\n      }\n    }\n    return sourceTiles;\n  };\n  /**\n   * @param {VectorRenderTile} tile Tile.\n   * @param {Array<import(\"../VectorTile\").default>} sourceTiles Source tiles.\n   */\n  VectorTile.prototype.addSourceTiles = function (tile, sourceTiles) {\n    this.sourceTilesByTileKey_[tile.getKey()] = sourceTiles;\n    for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n      sourceTiles[i].consumers++;\n    }\n  };\n  /**\n   * @param {VectorRenderTile} tile Tile.\n   */\n  VectorTile.prototype.removeSourceTiles = function (tile) {\n    var tileKey = tile.getKey();\n    if (tileKey in this.sourceTilesByTileKey_) {\n      var sourceTiles = this.sourceTilesByTileKey_[tileKey];\n      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        var sourceTile = sourceTiles[i];\n        sourceTile.consumers--;\n        if (sourceTile.consumers === 0) {\n          sourceTile.dispose();\n          delete this.sourceTileByCoordKey_[(0, _tilecoord.getKey)(sourceTile.tileCoord)];\n        }\n      }\n    }\n    delete this.sourceTilesByTileKey_[tileKey];\n  };\n  /**\n   * @inheritDoc\n   */\n  VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var coordKey = (0, _tilecoord.getKeyZXY)(z, x, y);\n    var key = this.getKey();\n    var tile;\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = /** @type {!import(\"../Tile.js\").default} */this.tileCache.get(coordKey);\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    var sourceExtent = this.getTileGrid().getExtent();\n    var tileGrid = this.getTileGridForProjection(projection);\n    if (urlTileCoord && sourceExtent) {\n      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      (0, _extent.buffer)(tileExtent, -tileGrid.getResolution(z), tileExtent);\n      if (!(0, _extent.intersects)(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n    var empty = true;\n    if (urlTileCoord !== null) {\n      var sourceTileGrid = this.tileGrid;\n      var resolution = tileGrid.getResolution(z);\n      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n      // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n      var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      (0, _extent.buffer)(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      }.bind(this));\n    }\n    var newTile = new _VectorRenderTile2.default(tileCoord, empty ? _TileState2.default.EMPTY : _TileState2.default.IDLE, urlTileCoord, this.tileGrid, this.getSourceTiles.bind(this, pixelRatio, projection), this.removeSourceTiles.bind(this));\n    newTile.key = key;\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n    return newTile;\n  };\n  /**\n   * @inheritDoc\n   */\n  VectorTile.prototype.getTileGridForProjection = function (projection) {\n    var code = projection.getCode();\n    var tileGrid = this.tileGrids_[code];\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      var sourceTileGrid = this.tileGrid;\n      tileGrid = (0, _tilegrid.createForProjection)(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\n      this.tileGrids_[code] = tileGrid;\n    }\n    return tileGrid;\n  };\n  /**\n   * @inheritDoc\n   */\n  VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n    return pixelRatio;\n  };\n  /**\n   * @inheritDoc\n   */\n  VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  };\n  return VectorTile;\n}(_UrlTile2.default);\nexports.default = VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\n\nfunction defaultLoadFunction(tile, url) {\n  var loader = (0, _featureloader.loadFeaturesXhr)(url, tile.getFormat(), tile.onLoad.bind(tile), tile.onError.bind(tile));\n  tile.setLoader(loader);\n}\n//# sourceMappingURL=VectorTile.js.map"},"hash":"97e627f6a203d175724f1047cd0ebec0"}