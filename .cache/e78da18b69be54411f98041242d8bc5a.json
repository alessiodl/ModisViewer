{"dependencies":[{"name":"../tilegrid/common.js","loc":{"line":17,"column":34}},{"name":"../extent.js","loc":{"line":18,"column":27}},{"name":"./Zoomify.js","loc":{"line":19,"column":27}},{"name":"../format/IIIFInfo.js","loc":{"line":20,"column":25}},{"name":"../asserts.js","loc":{"line":21,"column":23}},{"name":"../tilegrid/TileGrid.js","loc":{"line":22,"column":21}},{"name":"./TileImage.js","loc":{"line":23,"column":22}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _common = require(\"../tilegrid/common.js\");\n\nvar _extent = require(\"../extent.js\");\n\nvar _Zoomify = require(\"./Zoomify.js\");\n\nvar _IIIFInfo = require(\"../format/IIIFInfo.js\");\n\nvar _asserts = require(\"../asserts.js\");\n\nvar _TileGrid = require(\"../tilegrid/TileGrid.js\");\n\nvar _TileGrid2 = _interopRequireDefault(_TileGrid);\n\nvar _TileImage = require(\"./TileImage.js\");\n\nvar _TileImage2 = _interopRequireDefault(_TileImage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @module ol/source/IIIF\n */\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize]\n * @property {null|string} [crossOrigin]\n * @property {import(\"../extent.js\").Extent} [extent=[0, -height, width, 0]]\n * @property {string} [format='jpg'] Requested image format.\n * @property {import(\"../proj.js\").ProjectionLike} [projection]\n * @property {string} [quality] Requested IIIF image quality. Default is 'native'\n * for version 1, 'default' for versions 2 and 3.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {Array<number>} [resolutions] Supported resolutions as given in IIIF 'scaleFactors'\n * @property {import(\"../size.js\").Size} size Size of the image [width, height].\n * @property {Array<import(\"../size.js\").Size>} [sizes] Supported scaled image sizes.\n * Content of the IIIF info.json 'sizes' property, but as array of Size objects.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {Array<string>} [supports=[]] Supported IIIF region and size calculation\n * features.\n * @property {number} [tilePixelRatio]\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Same tile size is used for all zoom levels. If tile size is a number,\n * a square tile is assumed. If the IIIF image service supports arbitrary\n * tiling (sizeByH, sizeByW, sizeByWh or sizeByPct as well as regionByPx or regionByPct\n * are supported), the default tilesize is 256.\n * @property {number} [transition]\n * @property {string} [url] Base URL of the IIIF Image service.\n * This should be the same as the IIIF Image ID.\n * @property {Versions} [version=Versions.VERSION2] Service's IIIF Image API version.\n * @property {number} [zDirection=0] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\nfunction formatPercentage(percentage) {\n  return percentage.toLocaleString('en', { maximumFractionDigits: 10 });\n}\n/**\n * @classdesc\n * Layer source for IIIF Image API services.\n * @api\n */\nvar IIIF = /** @class */function (_super) {\n  __extends(IIIF, _super);\n  /**\n   * @param {Options} opt_options Tile source options. Use {@link import(\"../format/IIIFInfo.js\").IIIFInfo}\n   * to parse Image API service information responses into constructor options.\n   * @api\n   */\n  function IIIF(opt_options) {\n    var _this = this;\n    /**\n     * @type {Partial<Options>}\n     */\n    var options = opt_options || {};\n    var baseUrl = options.url || '';\n    baseUrl = baseUrl + (baseUrl.lastIndexOf('/') === baseUrl.length - 1 || baseUrl === '' ? '' : '/');\n    var version = options.version || _IIIFInfo.Versions.VERSION2;\n    var sizes = options.sizes || [];\n    var size = options.size;\n    (0, _asserts.assert)(size != undefined && Array.isArray(size) && size.length == 2 && !isNaN(size[0]) && size[0] > 0 && !isNaN(size[1]) && size[1] > 0, 60);\n    var width = size[0];\n    var height = size[1];\n    var tileSize = options.tileSize;\n    var tilePixelRatio = options.tilePixelRatio || 1;\n    var format = options.format || 'jpg';\n    var quality = options.quality || (options.version == _IIIFInfo.Versions.VERSION1 ? 'native' : 'default');\n    var resolutions = options.resolutions || [];\n    var supports = options.supports || [];\n    var extent = options.extent || [0, -height, width, 0];\n    var supportsListedSizes = sizes != undefined && Array.isArray(sizes) && sizes.length > 0;\n    var supportsListedTiles = tileSize != undefined && (typeof tileSize === 'number' && Number.isInteger(tileSize) && tileSize > 0 || Array.isArray(tileSize) && tileSize.length > 0);\n    var supportsArbitraryTiling = supports != undefined && Array.isArray(supports) && (supports.includes('regionByPx') || supports.includes('regionByPct')) && (supports.includes('sizeByWh') || supports.includes('sizeByH') || supports.includes('sizeByW') || supports.includes('sizeByPct'));\n    var tileWidth, tileHeight, maxZoom;\n    resolutions.sort(function (a, b) {\n      return b - a;\n    });\n    if (supportsListedTiles || supportsArbitraryTiling) {\n      if (tileSize != undefined) {\n        if (typeof tileSize === 'number' && Number.isInteger(tileSize) && tileSize > 0) {\n          tileWidth = tileSize;\n          tileHeight = tileSize;\n        } else if (Array.isArray(tileSize) && tileSize.length > 0) {\n          if (tileSize.length == 1 || tileSize[1] == undefined && Number.isInteger(tileSize[0])) {\n            tileWidth = tileSize[0];\n            tileHeight = tileSize[0];\n          }\n          if (tileSize.length == 2) {\n            if (Number.isInteger(tileSize[0]) && Number.isInteger(tileSize[1])) {\n              tileWidth = tileSize[0];\n              tileHeight = tileSize[1];\n            } else if (tileSize[0] == undefined && Number.isInteger(tileSize[1])) {\n              tileWidth = tileSize[1];\n              tileHeight = tileSize[1];\n            }\n          }\n        }\n      }\n      if (tileWidth === undefined || tileHeight === undefined) {\n        tileWidth = _common.DEFAULT_TILE_SIZE;\n        tileHeight = _common.DEFAULT_TILE_SIZE;\n      }\n      if (resolutions.length == 0) {\n        maxZoom = Math.max(Math.ceil(Math.log(width / tileWidth) / Math.LN2), Math.ceil(Math.log(height / tileHeight) / Math.LN2));\n        for (var i = maxZoom; i >= 0; i--) {\n          resolutions.push(Math.pow(2, i));\n        }\n      } else {\n        var maxScaleFactor = Math.max.apply(Math, resolutions);\n        // TODO maxScaleFactor might not be a power to 2\n        maxZoom = Math.round(Math.log(maxScaleFactor) / Math.LN2);\n      }\n    } else {\n      // No tile support.\n      tileWidth = width;\n      tileHeight = height;\n      resolutions = [];\n      if (supportsListedSizes) {\n        /*\n         * 'sizes' provided. Use full region in different resolutions. Every\n         * resolution has only one tile.\n         */\n        sizes.sort(function (a, b) {\n          return a[0] - b[0];\n        });\n        maxZoom = -1;\n        var ignoredSizesIndex = [];\n        for (var i = 0; i < sizes.length; i++) {\n          var resolution = width / sizes[i][0];\n          if (resolutions.length > 0 && resolutions[resolutions.length - 1] == resolution) {\n            ignoredSizesIndex.push(i);\n            continue;\n          }\n          resolutions.push(resolution);\n          maxZoom++;\n        }\n        if (ignoredSizesIndex.length > 0) {\n          for (var i = 0; i < ignoredSizesIndex.length; i++) {\n            sizes.splice(ignoredSizesIndex[i] - i, 1);\n          }\n        }\n      } else {\n        // No useful image information at all. Try pseudo tile with full image.\n        resolutions.push(1);\n        sizes.push([width, height]);\n        maxZoom = 0;\n      }\n    }\n    var tileGrid = new _TileGrid2.default({\n      tileSize: [tileWidth, tileHeight],\n      extent: extent,\n      origin: (0, _extent.getTopLeft)(extent),\n      resolutions: resolutions\n    });\n    var tileUrlFunction = function (tileCoord, pixelRatio, projection) {\n      var regionParam, sizeParam;\n      var zoom = tileCoord[0];\n      if (zoom > maxZoom) {\n        return;\n      }\n      var tileX = tileCoord[1],\n          tileY = tileCoord[2],\n          scale = resolutions[zoom];\n      if (tileX === undefined || tileY === undefined || scale === undefined || tileX < 0 || Math.ceil(width / scale / tileWidth) <= tileX || tileY < 0 || Math.ceil(height / scale / tileHeight) <= tileY) {\n        return;\n      }\n      if (supportsArbitraryTiling || supportsListedTiles) {\n        var regionX = tileX * tileWidth * scale,\n            regionY = tileY * tileHeight * scale;\n        var regionW = tileWidth * scale,\n            regionH = tileHeight * scale,\n            sizeW = tileWidth,\n            sizeH = tileHeight;\n        if (regionX + regionW > width) {\n          regionW = width - regionX;\n        }\n        if (regionY + regionH > height) {\n          regionH = height - regionY;\n        }\n        if (regionX + tileWidth * scale > width) {\n          sizeW = Math.floor((width - regionX + scale - 1) / scale);\n        }\n        if (regionY + tileHeight * scale > height) {\n          sizeH = Math.floor((height - regionY + scale - 1) / scale);\n        }\n        if (regionX == 0 && regionW == width && regionY == 0 && regionH == height) {\n          // canonical full image region parameter is 'full', not 'x,y,w,h'\n          regionParam = 'full';\n        } else if (!supportsArbitraryTiling || supports.includes('regionByPx')) {\n          regionParam = regionX + ',' + regionY + ',' + regionW + ',' + regionH;\n        } else if (supports.includes('regionByPct')) {\n          var pctX = formatPercentage(regionX / width * 100),\n              pctY = formatPercentage(regionY / height * 100),\n              pctW = formatPercentage(regionW / width * 100),\n              pctH = formatPercentage(regionH / height * 100);\n          regionParam = 'pct:' + pctX + ',' + pctY + ',' + pctW + ',' + pctH;\n        }\n        if (version == _IIIFInfo.Versions.VERSION3 && (!supportsArbitraryTiling || supports.includes('sizeByWh'))) {\n          sizeParam = sizeW + ',' + sizeH;\n        } else if (!supportsArbitraryTiling || supports.includes('sizeByW')) {\n          sizeParam = sizeW + ',';\n        } else if (supports.includes('sizeByH')) {\n          sizeParam = ',' + sizeH;\n        } else if (supports.includes('sizeByWh')) {\n          sizeParam = sizeW + ',' + sizeH;\n        } else if (supports.includes('sizeByPct')) {\n          sizeParam = 'pct:' + formatPercentage(100 / scale);\n        }\n      } else {\n        regionParam = 'full';\n        if (supportsListedSizes) {\n          var regionWidth = sizes[zoom][0],\n              regionHeight = sizes[zoom][1];\n          if (version == _IIIFInfo.Versions.VERSION3) {\n            if (regionWidth == width && regionHeight == height) {\n              sizeParam = 'max';\n            } else {\n              sizeParam = regionWidth + ',' + regionHeight;\n            }\n          } else {\n            if (regionWidth == width) {\n              sizeParam = 'full';\n            } else {\n              sizeParam = regionWidth + ',';\n            }\n          }\n        } else {\n          sizeParam = version == _IIIFInfo.Versions.VERSION3 ? 'max' : 'full';\n        }\n      }\n      return baseUrl + regionParam + '/' + sizeParam + '/0/' + quality + '.' + format;\n    };\n    var IiifTileClass = _Zoomify.CustomTile.bind(null, tilePixelRatio, tileGrid);\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      state: options.state,\n      tileClass: IiifTileClass,\n      tileGrid: tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: tileUrlFunction,\n      transition: options.transition\n    }) || this;\n    /**\n     * @inheritDoc\n     */\n    _this.zDirection = options.zDirection;\n    return _this;\n  }\n  return IIIF;\n}(_TileImage2.default);\nexports.default = IIIF;\n//# sourceMappingURL=IIIF.js.map"},"hash":"ae4dcbc168845adc61da879a580f3f58"}