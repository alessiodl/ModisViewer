{"dependencies":[{"name":"../Layer.js","loc":{"line":17,"column":26}},{"name":"../../webgl/Helper.js","loc":{"line":18,"column":24}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebGLWorkerMessageType = undefined;\nexports.writePointFeatureToBuffers = writePointFeatureToBuffers;\nexports.getBlankImageData = getBlankImageData;\nexports.colorEncodeId = colorEncodeId;\nexports.colorDecodeId = colorDecodeId;\n\nvar _Layer = require(\"../Layer.js\");\n\nvar _Layer2 = _interopRequireDefault(_Layer);\n\nvar _Helper = require(\"../../webgl/Helper.js\");\n\nvar _Helper2 = _interopRequireDefault(_Helper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/renderer/webgl/Layer\n */\n\n/**\n * @enum {string}\n */\nvar WebGLWorkerMessageType = exports.WebGLWorkerMessageType = {\n  GENERATE_BUFFERS: 'GENERATE_BUFFERS'\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object.<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object.<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n */\nvar WebGLLayerRenderer = /** @class */function (_super) {\n  __extends(WebGLLayerRenderer, _super);\n  /**\n   * @param {LayerType} layer Layer.\n   * @param {Options=} [opt_options] Options.\n   */\n  function WebGLLayerRenderer(layer, opt_options) {\n    var _this = _super.call(this, layer) || this;\n    var options = opt_options || {};\n    /**\n     * @type {WebGLHelper}\n     * @protected\n     */\n    _this.helper = new _Helper2.default({\n      postProcesses: options.postProcesses,\n      uniforms: options.uniforms\n    });\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n  WebGLLayerRenderer.prototype.disposeInternal = function () {\n    this.helper.dispose();\n    _super.prototype.disposeInternal.call(this);\n  };\n  /**\n   * Will return the last shader compilation errors. If no error happened, will return null;\n   * @return {string|null} Errors, or null if last compilation was successful\n   * @api\n   */\n  WebGLLayerRenderer.prototype.getShaderCompileErrors = function () {\n    return this.helper.getShaderCompileErrors();\n  };\n  return WebGLLayerRenderer;\n}(_Layer2.default);\nvar tmpArray_ = [];\nvar bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };\nfunction writePointVertex(buffer, pos, x, y, index) {\n  buffer[pos + 0] = x;\n  buffer[pos + 1] = y;\n  buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nfunction writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n  // This is for x, y and index\n  var baseVertexAttrsCount = 3;\n  var baseInstructionsCount = 2;\n  var stride = baseVertexAttrsCount + customAttributesCount;\n  var x = instructions[elementIndex + 0];\n  var y = instructions[elementIndex + 1];\n  // read custom numerical attributes on the feature\n  var customAttrs = tmpArray_;\n  customAttrs.length = customAttributesCount;\n  for (var i = 0; i < customAttrs.length; i++) {\n    customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n  }\n  var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n  var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n  var baseIndex = vPos / stride;\n  // push vertices for each of the four quad corners (first standard then custom attributes)\n  writePointVertex(vertexBuffer, vPos, x, y, 0);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 1);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 2);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  writePointVertex(vertexBuffer, vPos, x, y, 3);\n  customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n  vPos += stride;\n  indexBuffer[iPos++] = baseIndex;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 3;\n  indexBuffer[iPos++] = baseIndex + 1;\n  indexBuffer[iPos++] = baseIndex + 2;\n  indexBuffer[iPos++] = baseIndex + 3;\n  bufferPositions_.vertexPosition = vPos;\n  bufferPositions_.indexPosition = iPos;\n  return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nfunction getBlankImageData() {\n  var canvas = document.createElement('canvas');\n  var image = canvas.getContext('2d').createImageData(1, 1);\n  image.data[0] = 255;\n  image.data[1] = 255;\n  image.data[2] = 255;\n  image.data[3] = 255;\n  return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nfunction colorEncodeId(id, opt_array) {\n  var array = opt_array || [];\n  var radix = 256;\n  var divide = radix - 1;\n  array[0] = Math.floor(id / radix / radix / radix) / divide;\n  array[1] = Math.floor(id / radix / radix) % radix / divide;\n  array[2] = Math.floor(id / radix) % radix / divide;\n  array[3] = id % radix / divide;\n  return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nfunction colorDecodeId(color) {\n  var id = 0;\n  var radix = 256;\n  var mult = radix - 1;\n  id += Math.round(color[0] * radix * radix * radix * mult);\n  id += Math.round(color[1] * radix * radix * mult);\n  id += Math.round(color[2] * radix * mult);\n  id += Math.round(color[3] * mult);\n  return id;\n}\nexports.default = WebGLLayerRenderer;\n//# sourceMappingURL=Layer.js.map"},"hash":"cc60d4167cf82db4857bce072a0001d6"}