{"dependencies":[{"name":"../events/EventType.js","loc":{"line":17,"column":22}},{"name":"../Feature.js","loc":{"line":18,"column":20}},{"name":"../MapBrowserEventType.js","loc":{"line":19,"column":32}},{"name":"../MapBrowserPointerEvent.js","loc":{"line":20,"column":35}},{"name":"../Object.js","loc":{"line":21,"column":35}},{"name":"../coordinate.js","loc":{"line":22,"column":61}},{"name":"../events/Event.js","loc":{"line":23,"column":18}},{"name":"../events/condition.js","loc":{"line":24,"column":53}},{"name":"../extent.js","loc":{"line":25,"column":87}},{"name":"../functions.js","loc":{"line":26,"column":28}},{"name":"../geom/Circle.js","loc":{"line":27,"column":19}},{"name":"../geom/GeometryType.js","loc":{"line":28,"column":25}},{"name":"../geom/LineString.js","loc":{"line":29,"column":23}},{"name":"../geom/MultiLineString.js","loc":{"line":30,"column":28}},{"name":"../geom/MultiPoint.js","loc":{"line":31,"column":23}},{"name":"../geom/MultiPolygon.js","loc":{"line":32,"column":25}},{"name":"../geom/Point.js","loc":{"line":33,"column":18}},{"name":"../geom/Polygon.js","loc":{"line":34,"column":49}},{"name":"./Pointer.js","loc":{"line":35,"column":31}},{"name":"./Property.js","loc":{"line":36,"column":32}},{"name":"../layer/Vector.js","loc":{"line":37,"column":24}},{"name":"../source/Vector.js","loc":{"line":38,"column":25}},{"name":"../style/Style.js","loc":{"line":39,"column":35}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRegularPolygon = createRegularPolygon;\nexports.createBox = createBox;\n\nvar _EventType = require(\"../events/EventType.js\");\n\nvar _EventType2 = _interopRequireDefault(_EventType);\n\nvar _Feature = require(\"../Feature.js\");\n\nvar _Feature2 = _interopRequireDefault(_Feature);\n\nvar _MapBrowserEventType = require(\"../MapBrowserEventType.js\");\n\nvar _MapBrowserEventType2 = _interopRequireDefault(_MapBrowserEventType);\n\nvar _MapBrowserPointerEvent = require(\"../MapBrowserPointerEvent.js\");\n\nvar _MapBrowserPointerEvent2 = _interopRequireDefault(_MapBrowserPointerEvent);\n\nvar _Object = require(\"../Object.js\");\n\nvar _coordinate = require(\"../coordinate.js\");\n\nvar _Event = require(\"../events/Event.js\");\n\nvar _Event2 = _interopRequireDefault(_Event);\n\nvar _condition = require(\"../events/condition.js\");\n\nvar _extent = require(\"../extent.js\");\n\nvar _functions = require(\"../functions.js\");\n\nvar _Circle = require(\"../geom/Circle.js\");\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nvar _GeometryType = require(\"../geom/GeometryType.js\");\n\nvar _GeometryType2 = _interopRequireDefault(_GeometryType);\n\nvar _LineString = require(\"../geom/LineString.js\");\n\nvar _LineString2 = _interopRequireDefault(_LineString);\n\nvar _MultiLineString = require(\"../geom/MultiLineString.js\");\n\nvar _MultiLineString2 = _interopRequireDefault(_MultiLineString);\n\nvar _MultiPoint = require(\"../geom/MultiPoint.js\");\n\nvar _MultiPoint2 = _interopRequireDefault(_MultiPoint);\n\nvar _MultiPolygon = require(\"../geom/MultiPolygon.js\");\n\nvar _MultiPolygon2 = _interopRequireDefault(_MultiPolygon);\n\nvar _Point = require(\"../geom/Point.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Polygon = require(\"../geom/Polygon.js\");\n\nvar _Polygon2 = _interopRequireDefault(_Polygon);\n\nvar _Pointer = require(\"./Pointer.js\");\n\nvar _Pointer2 = _interopRequireDefault(_Pointer);\n\nvar _Property = require(\"./Property.js\");\n\nvar _Property2 = _interopRequireDefault(_Property);\n\nvar _Vector = require(\"../layer/Vector.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _Vector3 = require(\"../source/Vector.js\");\n\nvar _Vector4 = _interopRequireDefault(_Vector3);\n\nvar _Style = require(\"../style/Style.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/interaction/Draw\n */\n\n/**\n * @typedef {Object} Options\n * @property {GeometryType} type Geometry type of\n * the geometries being drawn with this instance.\n * @property {number} [clickTolerance=6] The maximum distance in pixels between\n * \"down\" and \"up\" for a \"up\" event to be considered a \"click\" event and\n * actually add a point/vertex to the geometry being drawn.  The default of `6`\n * was chosen for the draw interaction to behave correctly on mouse as well as\n * on touch devices.\n * @property {import(\"../Collection.js\").default<Feature>} [features]\n * Destination collection for the drawn features.\n * @property {VectorSource} [source] Destination source for\n * the drawn features.\n * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown\n * before the current vertex can be dragged to its exact position.\n * @property {number} [snapTolerance=12] Pixel distance for snapping to the\n * drawing finish.\n * @property {boolean} [stopClick=false] Stop click, singleclick, and\n * doubleclick events from firing during drawing.\n * @property {number} [maxPoints] The number of points that can be drawn before\n * a polygon ring or line string is finished. By default there is no\n * restriction.\n * @property {number} [minPoints] The number of points that must be drawn\n * before a polygon ring or line string can be finished. Default is `3` for\n * polygon rings and `2` for line strings.\n * @property {import(\"../events/condition.js\").Condition} [finishCondition] A function\n * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether the drawing can be finished.\n * @property {import(\"../style/Style.js\").StyleLike} [style]\n * Style for sketch features.\n * @property {GeometryFunction} [geometryFunction]\n * Function that is called when a geometry's coordinates are updated.\n * @property {string} [geometryName] Geometry name to use for features created\n * by the draw interaction.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,\n * adds a vertex or deactivates freehand drawing.\n * @property {boolean} [freehand=false] Operate in freehand mode for lines,\n * polygons, and circles.  This makes the interaction always operate in freehand\n * mode and takes precedence over any `freehandCondition` option.\n * @property {import(\"../events/condition.js\").Condition} [freehandCondition]\n * Condition that activates freehand drawing for lines and polygons. This\n * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and\n * returns a boolean to indicate whether that event should be handled. The\n * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the\n * Shift key activates freehand drawing.\n * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch\n * overlay.\n */\n/**\n * Coordinate type when drawing points.\n * @typedef {import(\"../coordinate.js\").Coordinate} PointCoordType\n */\n/**\n * Coordinate type when drawing lines.\n * @typedef {Array<import(\"../coordinate.js\").Coordinate>} LineCoordType\n */\n/**\n * Coordinate type when drawing polygons.\n * @typedef {Array<Array<import(\"../coordinate.js\").Coordinate>>} PolyCoordType\n */\n/**\n * Types used for drawing coordinates.\n * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType\n */\n/**\n * Function that takes an array of coordinates and an optional existing geometry as\n * arguments, and returns a geometry. The optional existing geometry is the\n * geometry that is returned when the function is called without a second\n * argument.\n * @typedef {function(!SketchCoordType, import(\"../geom/SimpleGeometry.js\").default=):\n *     import(\"../geom/SimpleGeometry.js\").default} GeometryFunction\n */\n/**\n * Draw mode.  This collapses multi-part geometry types with their single-part\n * cousins.\n * @enum {string}\n */\nvar Mode = {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  POLYGON: 'Polygon',\n  CIRCLE: 'Circle'\n};\n/**\n * @enum {string}\n */\nvar DrawEventType = {\n  /**\n   * Triggered upon feature draw start\n   * @event DrawEvent#drawstart\n   * @api\n   */\n  DRAWSTART: 'drawstart',\n  /**\n   * Triggered upon feature draw end\n   * @event DrawEvent#drawend\n   * @api\n   */\n  DRAWEND: 'drawend'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are\n * instances of this type.\n */\nvar DrawEvent = /** @class */function (_super) {\n  __extends(DrawEvent, _super);\n  /**\n   * @param {DrawEventType} type Type.\n   * @param {Feature} feature The feature drawn.\n   */\n  function DrawEvent(type, feature) {\n    var _this = _super.call(this, type) || this;\n    /**\n     * The feature being drawn.\n     * @type {Feature}\n     * @api\n     */\n    _this.feature = feature;\n    return _this;\n  }\n  return DrawEvent;\n}(_Event2.default);\n/**\n * @classdesc\n * Interaction for drawing feature geometries.\n *\n * @fires DrawEvent\n * @api\n */\nvar Draw = /** @class */function (_super) {\n  __extends(Draw, _super);\n  /**\n   * @param {Options} options Options.\n   */\n  function Draw(options) {\n    var _this = this;\n    var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */options;\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = _functions.FALSE;\n    }\n    _this = _super.call(this, pointerOptions) || this;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.shouldHandle_ = false;\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    _this.downPx_ = null;\n    /**\n     * @type {?}\n     * @private\n     */\n    _this.downTimeout_;\n    /**\n     * @type {number|undefined}\n     * @private\n     */\n    _this.lastDragTime_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n    _this.freehand_ = false;\n    /**\n     * Target source for drawn features.\n     * @type {VectorSource}\n     * @private\n     */\n    _this.source_ = options.source ? options.source : null;\n    /**\n     * Target collection for drawn features.\n     * @type {import(\"../Collection.js\").default<Feature>}\n     * @private\n     */\n    _this.features_ = options.features ? options.features : null;\n    /**\n     * Pixel distance for snapping.\n     * @type {number}\n     * @private\n     */\n    _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;\n    /**\n     * Geometry type.\n     * @type {GeometryType}\n     * @private\n     */\n    _this.type_ = /** @type {GeometryType} */options.type;\n    /**\n     * Drawing mode (derived from geometry type.\n     * @type {Mode}\n     * @private\n     */\n    _this.mode_ = getMode(_this.type_);\n    /**\n     * Stop click, singleclick, and doubleclick events from firing during drawing.\n     * Default is `false`.\n     * @type {boolean}\n     * @private\n     */\n    _this.stopClick_ = !!options.stopClick;\n    /**\n     * The number of points that must be drawn before a polygon ring or line\n     * string can be finished.  The default is 3 for polygon rings and 2 for\n     * line strings.\n     * @type {number}\n     * @private\n     */\n    _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Mode.POLYGON ? 3 : 2;\n    /**\n     * The number of points that can be drawn before a polygon ring or line string\n     * is finished. The default is no restriction.\n     * @type {number}\n     * @private\n     */\n    _this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;\n    /**\n     * A function to decide if a potential finish coordinate is permissible\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    _this.finishCondition_ = options.finishCondition ? options.finishCondition : _functions.TRUE;\n    var geometryFunction = options.geometryFunction;\n    if (!geometryFunction) {\n      if (_this.type_ === _GeometryType2.default.CIRCLE) {\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default=} opt_geometry Optional geometry.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, opt_geometry) {\n          var circle = opt_geometry ? /** @type {Circle} */opt_geometry : new _Circle2.default([NaN, NaN]);\n          var squaredLength = (0, _coordinate.squaredDistance)(coordinates[0], coordinates[1]);\n          circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));\n          return circle;\n        };\n      } else {\n        var Constructor_1;\n        var mode_1 = _this.mode_;\n        if (mode_1 === Mode.POINT) {\n          Constructor_1 = _Point2.default;\n        } else if (mode_1 === Mode.LINE_STRING) {\n          Constructor_1 = _LineString2.default;\n        } else if (mode_1 === Mode.POLYGON) {\n          Constructor_1 = _Polygon2.default;\n        }\n        /**\n         * @param {!LineCoordType} coordinates The coordinates.\n         * @param {import(\"../geom/SimpleGeometry.js\").default=} opt_geometry Optional geometry.\n         * @return {import(\"../geom/SimpleGeometry.js\").default} A geometry.\n         */\n        geometryFunction = function (coordinates, opt_geometry) {\n          var geometry = opt_geometry;\n          if (geometry) {\n            if (mode_1 === Mode.POLYGON) {\n              if (coordinates[0].length) {\n                // Add a closing coordinate to match the first\n                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);\n              } else {\n                geometry.setCoordinates([]);\n              }\n            } else {\n              geometry.setCoordinates(coordinates);\n            }\n          } else {\n            geometry = new Constructor_1(coordinates);\n          }\n          return geometry;\n        };\n      }\n    }\n    /**\n     * @type {GeometryFunction}\n     * @private\n     */\n    _this.geometryFunction_ = geometryFunction;\n    /**\n     * @type {number}\n     * @private\n     */\n    _this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;\n    /**\n     * Finish coordinate for the feature (first point for polygons, last point for\n     * linestrings).\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    _this.finishCoordinate_ = null;\n    /**\n     * Sketch feature.\n     * @type {Feature}\n     * @private\n     */\n    _this.sketchFeature_ = null;\n    /**\n     * Sketch point.\n     * @type {Feature<Point>}\n     * @private\n     */\n    _this.sketchPoint_ = null;\n    /**\n     * Sketch coordinates. Used when drawing a line or polygon.\n     * @type {SketchCoordType}\n     * @private\n     */\n    _this.sketchCoords_ = null;\n    /**\n     * Sketch line. Used when drawing polygon.\n     * @type {Feature<LineString>}\n     * @private\n     */\n    _this.sketchLine_ = null;\n    /**\n     * Sketch line coordinates. Used when drawing a polygon or circle.\n     * @type {LineCoordType}\n     * @private\n     */\n    _this.sketchLineCoords_ = null;\n    /**\n     * Squared tolerance for handling up events.  If the squared distance\n     * between a down and up event is greater than this tolerance, up events\n     * will not be handled.\n     * @type {number}\n     * @private\n     */\n    _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;\n    /**\n     * Draw overlay where our sketch features are drawn.\n     * @type {VectorLayer}\n     * @private\n     */\n    _this.overlay_ = new _Vector2.default({\n      source: new _Vector4.default({\n        useSpatialIndex: false,\n        wrapX: options.wrapX ? options.wrapX : false\n      }),\n      style: options.style ? options.style : getDefaultStyleFunction(),\n      updateWhileInteracting: true\n    });\n    /**\n     * Name of the geometry attribute for newly created features.\n     * @type {string|undefined}\n     * @private\n     */\n    _this.geometryName_ = options.geometryName;\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    _this.condition_ = options.condition ? options.condition : _condition.noModifierKeys;\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    _this.freehandCondition_;\n    if (options.freehand) {\n      _this.freehandCondition_ = _condition.always;\n    } else {\n      _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : _condition.shiftKeyOnly;\n    }\n    _this.addEventListener((0, _Object.getChangeEventType)(_Property2.default.ACTIVE), _this.updateState_);\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n  Draw.prototype.setMap = function (map) {\n    _super.prototype.setMap.call(this, map);\n    this.updateState_();\n  };\n  /**\n   * Get the overlay layer that this interaction renders sketch features to.\n   * @return {VectorLayer} Overlay layer.\n   * @api\n   */\n  Draw.prototype.getOverlay = function () {\n    return this.overlay_;\n  };\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.\n   * @override\n   * @api\n   */\n  Draw.prototype.handleEvent = function (event) {\n    if (event.originalEvent.type === _EventType2.default.CONTEXTMENU) {\n      // Avoid context menu for long taps when drawing on mobile\n      event.preventDefault();\n    }\n    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);\n    var move = event.type === _MapBrowserEventType2.default.POINTERMOVE;\n    var pass = true;\n    if (!this.freehand_ && this.lastDragTime_ && event.type === _MapBrowserEventType2.default.POINTERDRAG) {\n      var now = Date.now();\n      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {\n        this.downPx_ = event.pixel;\n        this.shouldHandle_ = !this.freehand_;\n        move = true;\n      } else {\n        this.lastDragTime_ = undefined;\n      }\n      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {\n        clearTimeout(this.downTimeout_);\n        this.downTimeout_ = undefined;\n      }\n    }\n    if (this.freehand_ && event.type === _MapBrowserEventType2.default.POINTERDRAG && this.sketchFeature_ !== null) {\n      this.addToDrawing_(event);\n      pass = false;\n    } else if (this.freehand_ && event.type === _MapBrowserEventType2.default.POINTERDOWN) {\n      pass = false;\n    } else if (move) {\n      pass = event.type === _MapBrowserEventType2.default.POINTERMOVE;\n      if (pass && this.freehand_) {\n        pass = this.handlePointerMove_(event);\n      } else if ( /** @type {MapBrowserPointerEvent} */event.pointerEvent.pointerType == 'mouse' || event.type === _MapBrowserEventType2.default.POINTERDRAG && this.downTimeout_ === undefined) {\n        this.handlePointerMove_(event);\n      }\n    } else if (event.type === _MapBrowserEventType2.default.DBLCLICK) {\n      pass = false;\n    }\n    return _super.prototype.handleEvent.call(this, event) && pass;\n  };\n  /**\n   * @inheritDoc\n   */\n  Draw.prototype.handleDownEvent = function (event) {\n    this.shouldHandle_ = !this.freehand_;\n    if (this.freehand_) {\n      this.downPx_ = event.pixel;\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event);\n      }\n      return true;\n    } else if (this.condition_(event)) {\n      this.lastDragTime_ = Date.now();\n      this.downTimeout_ = setTimeout(function () {\n        this.handlePointerMove_(new _MapBrowserPointerEvent2.default(_MapBrowserEventType2.default.POINTERMOVE, event.map, event.pointerEvent, false, event.frameState));\n      }.bind(this), this.dragVertexDelay_);\n      this.downPx_ = event.pixel;\n      return true;\n    } else {\n      this.lastDragTime_ = undefined;\n      return false;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  Draw.prototype.handleUpEvent = function (event) {\n    var pass = true;\n    if (this.downTimeout_) {\n      clearTimeout(this.downTimeout_);\n      this.downTimeout_ = undefined;\n    }\n    this.handlePointerMove_(event);\n    var circleMode = this.mode_ === Mode.CIRCLE;\n    if (this.shouldHandle_) {\n      if (!this.finishCoordinate_) {\n        this.startDrawing_(event);\n        if (this.mode_ === Mode.POINT) {\n          this.finishDrawing();\n        }\n      } else if (this.freehand_ || circleMode) {\n        this.finishDrawing();\n      } else if (this.atFinish_(event)) {\n        if (this.finishCondition_(event)) {\n          this.finishDrawing();\n        }\n      } else {\n        this.addToDrawing_(event);\n      }\n      pass = false;\n    } else if (this.freehand_) {\n      this.finishCoordinate_ = null;\n      this.abortDrawing_();\n    }\n    if (!pass && this.stopClick_) {\n      event.stopPropagation();\n    }\n    return pass;\n  };\n  /**\n   * Handle move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} event A move event.\n   * @return {boolean} Pass the event to other interactions.\n   * @private\n   */\n  Draw.prototype.handlePointerMove_ = function (event) {\n    if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {\n      var downPx = this.downPx_;\n      var clickPx = event.pixel;\n      var dx = downPx[0] - clickPx[0];\n      var dy = downPx[1] - clickPx[1];\n      var squaredDistance = dx * dx + dy * dy;\n      this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;\n      if (!this.shouldHandle_) {\n        return true;\n      }\n    }\n    if (this.finishCoordinate_) {\n      this.modifyDrawing_(event);\n    } else {\n      this.createOrUpdateSketchPoint_(event);\n    }\n    return true;\n  };\n  /**\n   * Determine if an event is within the snapping tolerance of the start coord.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} The event is within the snapping tolerance of the start.\n   * @private\n   */\n  Draw.prototype.atFinish_ = function (event) {\n    var at = false;\n    if (this.sketchFeature_) {\n      var potentiallyDone = false;\n      var potentiallyFinishCoordinates = [this.finishCoordinate_];\n      if (this.mode_ === Mode.LINE_STRING) {\n        potentiallyDone = this.sketchCoords_.length > this.minPoints_;\n      } else if (this.mode_ === Mode.POLYGON) {\n        var sketchCoords = /** @type {PolyCoordType} */this.sketchCoords_;\n        potentiallyDone = sketchCoords[0].length > this.minPoints_;\n        potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];\n      }\n      if (potentiallyDone) {\n        var map = event.map;\n        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {\n          var finishCoordinate = potentiallyFinishCoordinates[i];\n          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);\n          var pixel = event.pixel;\n          var dx = pixel[0] - finishPixel[0];\n          var dy = pixel[1] - finishPixel[1];\n          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;\n          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;\n          if (at) {\n            this.finishCoordinate_ = finishCoordinate;\n            break;\n          }\n        }\n      }\n    }\n    return at;\n  };\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  Draw.prototype.createOrUpdateSketchPoint_ = function (event) {\n    var coordinates = event.coordinate.slice();\n    if (!this.sketchPoint_) {\n      this.sketchPoint_ = new _Feature2.default(new _Point2.default(coordinates));\n      this.updateSketchFeatures_();\n    } else {\n      var sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinates);\n    }\n  };\n  /**\n   * Start the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  Draw.prototype.startDrawing_ = function (event) {\n    var start = event.coordinate;\n    this.finishCoordinate_ = start;\n    if (this.mode_ === Mode.POINT) {\n      this.sketchCoords_ = start.slice();\n    } else if (this.mode_ === Mode.POLYGON) {\n      this.sketchCoords_ = [[start.slice(), start.slice()]];\n      this.sketchLineCoords_ = this.sketchCoords_[0];\n    } else {\n      this.sketchCoords_ = [start.slice(), start.slice()];\n    }\n    if (this.sketchLineCoords_) {\n      this.sketchLine_ = new _Feature2.default(new _LineString2.default(this.sketchLineCoords_));\n    }\n    var geometry = this.geometryFunction_(this.sketchCoords_);\n    this.sketchFeature_ = new _Feature2.default();\n    if (this.geometryName_) {\n      this.sketchFeature_.setGeometryName(this.geometryName_);\n    }\n    this.sketchFeature_.setGeometry(geometry);\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  /**\n   * Modify the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  Draw.prototype.modifyDrawing_ = function (event) {\n    var coordinate = event.coordinate;\n    var geometry = this.sketchFeature_.getGeometry();\n    var coordinates, last;\n    if (this.mode_ === Mode.POINT) {\n      last = this.sketchCoords_;\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates = /** @type {PolyCoordType} */this.sketchCoords_[0];\n      last = coordinates[coordinates.length - 1];\n      if (this.atFinish_(event)) {\n        // snap to finish\n        coordinate = this.finishCoordinate_.slice();\n      }\n    } else {\n      coordinates = this.sketchCoords_;\n      last = coordinates[coordinates.length - 1];\n    }\n    last[0] = coordinate[0];\n    last[1] = coordinate[1];\n    this.geometryFunction_( /** @type {!LineCoordType} */this.sketchCoords_, geometry);\n    if (this.sketchPoint_) {\n      var sketchPointGeom = this.sketchPoint_.getGeometry();\n      sketchPointGeom.setCoordinates(coordinate);\n    }\n    /** @type {LineString} */\n    var sketchLineGeom;\n    if (geometry.getType() == _GeometryType2.default.POLYGON && this.mode_ !== Mode.POLYGON) {\n      if (!this.sketchLine_) {\n        this.sketchLine_ = new _Feature2.default();\n      }\n      var ring = geometry.getLinearRing(0);\n      sketchLineGeom = this.sketchLine_.getGeometry();\n      if (!sketchLineGeom) {\n        sketchLineGeom = new _LineString2.default(ring.getFlatCoordinates(), ring.getLayout());\n        this.sketchLine_.setGeometry(sketchLineGeom);\n      } else {\n        sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());\n        sketchLineGeom.changed();\n      }\n    } else if (this.sketchLineCoords_) {\n      sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(this.sketchLineCoords_);\n    }\n    this.updateSketchFeatures_();\n  };\n  /**\n   * Add a new coordinate to the drawing.\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @private\n   */\n  Draw.prototype.addToDrawing_ = function (event) {\n    var coordinate = event.coordinate;\n    var geometry = this.sketchFeature_.getGeometry();\n    var done;\n    var coordinates;\n    if (this.mode_ === Mode.LINE_STRING) {\n      this.finishCoordinate_ = coordinate.slice();\n      coordinates = /** @type {LineCoordType} */this.sketchCoords_;\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      this.geometryFunction_(coordinates, geometry);\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates = /** @type {PolyCoordType} */this.sketchCoords_[0];\n      if (coordinates.length >= this.maxPoints_) {\n        if (this.freehand_) {\n          coordinates.pop();\n        } else {\n          done = true;\n        }\n      }\n      coordinates.push(coordinate.slice());\n      if (done) {\n        this.finishCoordinate_ = coordinates[0];\n      }\n      this.geometryFunction_(this.sketchCoords_, geometry);\n    }\n    this.updateSketchFeatures_();\n    if (done) {\n      this.finishDrawing();\n    }\n  };\n  /**\n   * Remove last point of the feature currently being drawn.\n   * @api\n   */\n  Draw.prototype.removeLastPoint = function () {\n    if (!this.sketchFeature_) {\n      return;\n    }\n    var geometry = this.sketchFeature_.getGeometry();\n    var coordinates;\n    /** @type {LineString} */\n    var sketchLineGeom;\n    if (this.mode_ === Mode.LINE_STRING) {\n      coordinates = /** @type {LineCoordType} */this.sketchCoords_;\n      coordinates.splice(-2, 1);\n      this.geometryFunction_(coordinates, geometry);\n      if (coordinates.length >= 2) {\n        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();\n      }\n    } else if (this.mode_ === Mode.POLYGON) {\n      coordinates = /** @type {PolyCoordType} */this.sketchCoords_[0];\n      coordinates.splice(-2, 1);\n      sketchLineGeom = this.sketchLine_.getGeometry();\n      sketchLineGeom.setCoordinates(coordinates);\n      this.geometryFunction_(this.sketchCoords_, geometry);\n    }\n    if (coordinates.length === 0) {\n      this.finishCoordinate_ = null;\n    }\n    this.updateSketchFeatures_();\n  };\n  /**\n   * Stop drawing and add the sketch feature to the target layer.\n   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is\n   * dispatched before inserting the feature.\n   * @api\n   */\n  Draw.prototype.finishDrawing = function () {\n    var sketchFeature = this.abortDrawing_();\n    if (!sketchFeature) {\n      return;\n    }\n    var coordinates = this.sketchCoords_;\n    var geometry = sketchFeature.getGeometry();\n    if (this.mode_ === Mode.LINE_STRING) {\n      // remove the redundant last point\n      coordinates.pop();\n      this.geometryFunction_(coordinates, geometry);\n    } else if (this.mode_ === Mode.POLYGON) {\n      // remove the redundant last point in ring\n      /** @type {PolyCoordType} */coordinates[0].pop();\n      this.geometryFunction_(coordinates, geometry);\n      coordinates = geometry.getCoordinates();\n    }\n    // cast multi-part geometries\n    if (this.type_ === _GeometryType2.default.MULTI_POINT) {\n      sketchFeature.setGeometry(new _MultiPoint2.default([/** @type {PointCoordType} */coordinates]));\n    } else if (this.type_ === _GeometryType2.default.MULTI_LINE_STRING) {\n      sketchFeature.setGeometry(new _MultiLineString2.default([/** @type {LineCoordType} */coordinates]));\n    } else if (this.type_ === _GeometryType2.default.MULTI_POLYGON) {\n      sketchFeature.setGeometry(new _MultiPolygon2.default([/** @type {PolyCoordType} */coordinates]));\n    }\n    // First dispatch event to allow full set up of feature\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));\n    // Then insert feature\n    if (this.features_) {\n      this.features_.push(sketchFeature);\n    }\n    if (this.source_) {\n      this.source_.addFeature(sketchFeature);\n    }\n  };\n  /**\n   * Stop drawing without adding the sketch feature to the target layer.\n   * @return {Feature} The sketch feature (or null if none).\n   * @private\n   */\n  Draw.prototype.abortDrawing_ = function () {\n    this.finishCoordinate_ = null;\n    var sketchFeature = this.sketchFeature_;\n    if (sketchFeature) {\n      this.sketchFeature_ = null;\n      this.sketchPoint_ = null;\n      this.sketchLine_ = null;\n      this.overlay_.getSource().clear(true);\n    }\n    return sketchFeature;\n  };\n  /**\n   * Extend an existing geometry by adding additional points. This only works\n   * on features with `LineString` geometries, where the interaction will\n   * extend lines by adding points to the end of the coordinates array.\n   * @param {!Feature<LineString>} feature Feature to be extended.\n   * @api\n   */\n  Draw.prototype.extend = function (feature) {\n    var geometry = feature.getGeometry();\n    var lineString = geometry;\n    this.sketchFeature_ = feature;\n    this.sketchCoords_ = lineString.getCoordinates();\n    var last = this.sketchCoords_[this.sketchCoords_.length - 1];\n    this.finishCoordinate_ = last.slice();\n    this.sketchCoords_.push(last.slice());\n    this.updateSketchFeatures_();\n    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));\n  };\n  /**\n   * Redraw the sketch features.\n   * @private\n   */\n  Draw.prototype.updateSketchFeatures_ = function () {\n    var sketchFeatures = [];\n    if (this.sketchFeature_) {\n      sketchFeatures.push(this.sketchFeature_);\n    }\n    if (this.sketchLine_) {\n      sketchFeatures.push(this.sketchLine_);\n    }\n    if (this.sketchPoint_) {\n      sketchFeatures.push(this.sketchPoint_);\n    }\n    var overlaySource = this.overlay_.getSource();\n    overlaySource.clear(true);\n    overlaySource.addFeatures(sketchFeatures);\n  };\n  /**\n   * @private\n   */\n  Draw.prototype.updateState_ = function () {\n    var map = this.getMap();\n    var active = this.getActive();\n    if (!map || !active) {\n      this.abortDrawing_();\n    }\n    this.overlay_.setMap(active ? map : null);\n  };\n  return Draw;\n}(_Pointer2.default);\n/**\n * @return {import(\"../style/Style.js\").StyleFunction} Styles.\n */\nfunction getDefaultStyleFunction() {\n  var styles = (0, _Style.createEditingStyle)();\n  return function (feature, resolution) {\n    return styles[feature.getGeometry().getType()];\n  };\n}\n/**\n * Create a `geometryFunction` for `type: 'Circle'` that will create a regular\n * polygon with a user specified number of sides and start angle instead of an\n * `import(\"../geom/Circle.js\").Circle` geometry.\n * @param {number=} opt_sides Number of sides of the regular polygon. Default is\n *     32.\n * @param {number=} opt_angle Angle of the first point in radians. 0 means East.\n *     Default is the angle defined by the heading from the center of the\n *     regular polygon to the current pointer position.\n * @return {GeometryFunction} Function that draws a\n *     polygon.\n * @api\n */\nfunction createRegularPolygon(opt_sides, opt_angle) {\n  return function (coordinates, opt_geometry) {\n    var center = /** @type {LineCoordType} */coordinates[0];\n    var end = /** @type {LineCoordType} */coordinates[1];\n    var radius = Math.sqrt((0, _coordinate.squaredDistance)(center, end));\n    var geometry = opt_geometry ? /** @type {Polygon} */opt_geometry : (0, _Polygon.fromCircle)(new _Circle2.default(center), opt_sides);\n    var angle = opt_angle;\n    if (!opt_angle) {\n      var x = end[0] - center[0];\n      var y = end[1] - center[1];\n      angle = Math.atan(y / x) - (x < 0 ? Math.PI : 0);\n    }\n    (0, _Polygon.makeRegular)(geometry, center, radius, angle);\n    return geometry;\n  };\n}\n/**\n * Create a `geometryFunction` that will create a box-shaped polygon (aligned\n * with the coordinate system axes).  Use this with the draw interaction and\n * `type: 'Circle'` to return a box instead of a circle geometry.\n * @return {GeometryFunction} Function that draws a box-shaped polygon.\n * @api\n */\nfunction createBox() {\n  return function (coordinates, opt_geometry) {\n    var extent = (0, _extent.boundingExtent)( /** @type {LineCoordType} */coordinates);\n    var boxCoordinates = [[(0, _extent.getBottomLeft)(extent), (0, _extent.getBottomRight)(extent), (0, _extent.getTopRight)(extent), (0, _extent.getTopLeft)(extent), (0, _extent.getBottomLeft)(extent)]];\n    var geometry = opt_geometry;\n    if (geometry) {\n      geometry.setCoordinates(boxCoordinates);\n    } else {\n      geometry = new _Polygon2.default(boxCoordinates);\n    }\n    return geometry;\n  };\n}\n/**\n * Get the drawing mode.  The mode for mult-part geometries is the same as for\n * their single-part cousins.\n * @param {GeometryType} type Geometry type.\n * @return {Mode} Drawing mode.\n */\nfunction getMode(type) {\n  var mode;\n  if (type === _GeometryType2.default.POINT || type === _GeometryType2.default.MULTI_POINT) {\n    mode = Mode.POINT;\n  } else if (type === _GeometryType2.default.LINE_STRING || type === _GeometryType2.default.MULTI_LINE_STRING) {\n    mode = Mode.LINE_STRING;\n  } else if (type === _GeometryType2.default.POLYGON || type === _GeometryType2.default.MULTI_POLYGON) {\n    mode = Mode.POLYGON;\n  } else if (type === _GeometryType2.default.CIRCLE) {\n    mode = Mode.CIRCLE;\n  }\n  return (\n    /** @type {!Mode} */mode\n  );\n}\nexports.default = Draw;\n//# sourceMappingURL=Draw.js.map"},"hash":"cda35661e4c8882fdadf9482e1526d45"}