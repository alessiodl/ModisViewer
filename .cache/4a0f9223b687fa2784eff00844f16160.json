{"dependencies":[{"name":"../../array.js","loc":{"line":17,"column":42}},{"name":"../../dom.js","loc":{"line":18,"column":38}},{"name":"../../extent.js","loc":{"line":19,"column":54}},{"name":"../../geom/flat/transform.js","loc":{"line":20,"column":28}},{"name":"../../obj.js","loc":{"line":21,"column":24}},{"name":"./BuilderType.js","loc":{"line":22,"column":24}},{"name":"../../transform.js","loc":{"line":23,"column":71}},{"name":"./Executor.js","loc":{"line":24,"column":21}},{"name":"../../Disposable.js","loc":{"line":25,"column":23}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCircleArray = getCircleArray;\nexports.replayDeclutter = replayDeclutter;\n\nvar _array = require(\"../../array.js\");\n\nvar _dom = require(\"../../dom.js\");\n\nvar _extent = require(\"../../extent.js\");\n\nvar _transform = require(\"../../geom/flat/transform.js\");\n\nvar _obj = require(\"../../obj.js\");\n\nvar _BuilderType = require(\"./BuilderType.js\");\n\nvar _BuilderType2 = _interopRequireDefault(_BuilderType);\n\nvar _transform2 = require(\"../../transform.js\");\n\nvar _Executor = require(\"./Executor.js\");\n\nvar _Executor2 = _interopRequireDefault(_Executor);\n\nvar _Disposable = require(\"../../Disposable.js\");\n\nvar _Disposable2 = _interopRequireDefault(_Disposable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @module ol/render/canvas/ExecutorGroup\n */\nvar __extends = undefined && undefined.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n/**\n * @const\n * @type {Array<BuilderType>}\n */\nvar ORDER = [_BuilderType2.default.POLYGON, _BuilderType2.default.CIRCLE, _BuilderType2.default.LINE_STRING, _BuilderType2.default.IMAGE, _BuilderType2.default.TEXT, _BuilderType2.default.DEFAULT];\nvar ExecutorGroup = /** @class */function (_super) {\n  __extends(ExecutorGroup, _super);\n  /**\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent for clipping. When a\n   * `maxExtent` was set on the Buillder for this executor group, the same `maxExtent`\n   * should be set here, unless the target context does not exceet that extent (which\n   * can be the case when rendering to tiles).\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The executor group can have overlapping geometries.\n   * @param {!Object<string, !Object<BuilderType, import(\"./Builder.js\").SerializableInstructions>>} allInstructions\n   * The serializable instructions.\n   * @param {number=} opt_renderBuffer Optional rendering buffer.\n   */\n  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {\n    var _this = _super.call(this) || this;\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    _this.maxExtent_ = maxExtent;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    _this.overlaps_ = overlaps;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n    _this.resolution_ = resolution;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    _this.renderBuffer_ = opt_renderBuffer;\n    /**\n     * @private\n     * @type {!Object<string, !Object<BuilderType, import(\"./Executor\").default>>}\n     */\n    _this.executorsByZIndex_ = {};\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    _this.hitDetectionContext_ = null;\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    _this.hitDetectionTransform_ = (0, _transform2.create)();\n    _this.createExecutors_(allInstructions);\n    return _this;\n  }\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  ExecutorGroup.prototype.clip = function (context, transform) {\n    var flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n  /**\n   * Create executors and populate them using the provided instructions.\n   * @private\n   * @param {!Object<string, !Object<BuilderType, import(\"./Builder.js\").SerializableInstructions>>} allInstructions The serializable instructions\n   */\n  ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {\n    for (var zIndex in allInstructions) {\n      var executors = this.executorsByZIndex_[zIndex];\n      if (executors === undefined) {\n        executors = {};\n        this.executorsByZIndex_[zIndex] = executors;\n      }\n      var instructionByZindex = allInstructions[zIndex];\n      for (var builderType in instructionByZindex) {\n        var instructions = instructionByZindex[builderType];\n        executors[builderType] = new _Executor2.default(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);\n      }\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  ExecutorGroup.prototype.disposeInternal = function () {\n    for (var z in this.executorsByZIndex_) {\n      var executors = this.executorsByZIndex_[z];\n      for (var key in executors) {\n        executors[key].disposeInternal();\n      }\n    }\n    if (this.hitDetectionContext_) {\n      var canvas = this.hitDetectionContext_.canvas;\n      canvas.width = 0;\n      canvas.height = 0;\n    }\n    _super.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @param {Array<BuilderType>} executors Executors.\n   * @return {boolean} Has executors of the provided types.\n   */\n  ExecutorGroup.prototype.hasExecutors = function (executors) {\n    for (var zIndex in this.executorsByZIndex_) {\n      var candidates = this.executorsByZIndex_[zIndex];\n      for (var i = 0, ii = executors.length; i < ii; ++i) {\n        if (executors[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../../Feature.js\").FeatureLike): T} callback Feature callback.\n   * @param {Array<import(\"../../Feature.js\").FeatureLike>} declutteredFeatures Decluttered features.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {\n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform = (0, _transform2.compose)(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    if (!this.hitDetectionContext_) {\n      this.hitDetectionContext_ = (0, _dom.createCanvasContext2D)(contextSize, contextSize);\n    }\n    var context = this.hitDetectionContext_;\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    var hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = (0, _extent.createEmpty)();\n      (0, _extent.extendCoordinate)(hitExtent, coordinate);\n      (0, _extent.buffer)(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n    var mask = getCircleArray(hitTolerance);\n    var builderType;\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @return {?} Callback result.\n     */\n    function featureCallback(feature) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (var i_1 = 0; i_1 < contextSize; i_1++) {\n        for (var j_1 = 0; j_1 < contextSize; j_1++) {\n          if (mask[i_1][j_1]) {\n            if (imageData[(j_1 * contextSize + i_1) * 4 + 3] > 0) {\n              var result_1 = void 0;\n              if (!(declutteredFeatures && (builderType == _BuilderType2.default.IMAGE || builderType == _BuilderType2.default.TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {\n                result_1 = callback(feature);\n              }\n              if (result_1) {\n                return result_1;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(_array.numberSafeCompareFunction);\n    var i, j, executors, executor, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      var zIndexKey = zs[i].toString();\n      executors = this.executorsByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        builderType = ORDER[j];\n        executor = executors[builderType];\n        if (executor !== undefined) {\n          result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    return undefined;\n  };\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n  ExecutorGroup.prototype.getClipCoords = function (transform) {\n    var maxExtent = this.maxExtent_;\n    if (!maxExtent) {\n      return null;\n    }\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    (0, _transform.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  };\n  /**\n   * @return {boolean} Is empty.\n   */\n  ExecutorGroup.prototype.isEmpty = function () {\n    return (0, _obj.isEmpty)(this.executorsByZIndex_);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<BuilderType>=} opt_builderTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n  ExecutorGroup.prototype.execute = function (context, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterReplays) {\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.executorsByZIndex_).map(Number);\n    zs.sort(_array.numberSafeCompareFunction);\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    if (this.maxExtent_) {\n      context.save();\n      this.clip(context, transform);\n    }\n    var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;\n    var i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.executorsByZIndex_[zIndexKey];\n      for (j = 0, jj = builderTypes.length; j < jj; ++j) {\n        var builderType = builderTypes[j];\n        replay = replays[builderType];\n        if (replay !== undefined) {\n          if (opt_declutterReplays && (builderType == _BuilderType2.default.IMAGE || builderType == _BuilderType2.default.TEXT)) {\n            var declutter = opt_declutterReplays[zIndexKey];\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.execute(context, transform, viewRotation, snapToPixel);\n          }\n        }\n      }\n    }\n    if (this.maxExtent_) {\n      context.restore();\n    }\n  };\n  return ExecutorGroup;\n}(_Disposable2.default);\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\nvar circleArrayCache = {\n  0: [[true]]\n};\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  var i;\n  var radius = Math.floor(array.length / 2);\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\nfunction getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n  var arraySize = radius * 2 + 1;\n  var arr = new Array(arraySize);\n  for (var i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n  var x = radius;\n  var y = 0;\n  var error = 0;\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n    y++;\n    error += 1 + 2 * y;\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {number} opacity Opacity.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n * @param {Array<import(\"../../PluggableMap.js\").DeclutterItems>} declutterItems Declutter items.\n */\nfunction replayDeclutter(declutterReplays, context, rotation, opacity, snapToPixel, declutterItems) {\n  var zs = Object.keys(declutterReplays).map(Number).sort(_array.numberSafeCompareFunction);\n  for (var z = 0, zz = zs.length; z < zz; ++z) {\n    var executorData = declutterReplays[zs[z].toString()];\n    var currentExecutor = void 0;\n    for (var i = 0, ii = executorData.length; i < ii;) {\n      var executor = executorData[i++];\n      if (executor !== currentExecutor) {\n        currentExecutor = executor;\n        declutterItems.push({\n          items: executor.declutterItems,\n          opacity: opacity\n        });\n      }\n      var transform = executorData[i++];\n      executor.execute(context, transform, rotation, snapToPixel);\n    }\n  }\n}\nexports.default = ExecutorGroup;\n//# sourceMappingURL=ExecutorGroup.js.map"},"hash":"513b15120a3d6b334c89f97d4e6d984e"}